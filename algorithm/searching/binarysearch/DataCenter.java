package algorithm.searching.binarysearch;

/**
 * 데이터 센터
 * 문제 링크: X
 *
 * 문제
 *
 * 입력
 * [1, 2, 8, 4, 9], 3
 * [9, 12, 14, 6, 7], 4
 * [5, 12, 34, 16, 18, 23, 29, 15], 7
 * [1, 3, 6, 11, 18, 27, 38, 41, 56, 73, 92, 113], 8
 *
 * 출력
 * 3
 * 2
 * 3
 * 10
 *
 * 제한사항
 * • nums의 길이는 3이상 10,000 이하입니다.
 * • nums의 원소값은 0이상 1,000,000,000 이하입니다. • C(2 <= C <= N)
 *
 * 시간 제한: 10초
 * 메모리 제한: 128MB
 *
 * 접근 방법
 * - 마구간 위치 오름차순 정렬.
 * - 배치 가능한 말의 수가 주어진 말의 수(C) 이상이면 거리를 늘리고, 그렇지 않으면 줄여 이진탐색.
 *
 * 알고리즘 복잡도: O(N lon N)
 */
public class DataCenter {
    public int solution(int[][] board) {
        int answer = 0;

        return answer;
    }

    public static void main() {
        DataCenter T = new DataCenter();

        System.out.println(T.solution(new int[][]{
                {2, 3, 1, 5, 6},
                {3, 0, 7, 4, 3},
                {8, 5, 7, 5, 6},
                {9, 6, 1, 5, 5},
                {5, 5, 8, 5, 1}}));
        System.out.println(T.solution(new int[][]{
                {6, 23, 45, 51, 62},
                {3, 77, 18, 54, 33},
                {58, 85, 12, 5, 36},
                {59, 56, 51, 57, 59},
                {52, 54, 83, 52, 19}}));
        System.out.println(T.solution(new int[][]{
                {35, 6, 23, 45, 51, 62},
                {33, 45, 76, 190, 89, 39},
                {25, 3, 77, 18, 54, 33},
                {123, 58, 85, 12, 5, 36},
                {36, 59, 56, 51, 57, 59},
                {56, 52, 54, 83, 52, 19}}));
    }
}
